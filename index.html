<!DOCTYPE html>
<html>
<head>
<title>qemu笔记.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<p>需要解决的问题：</p>
<ol>
<li>如何使用qemu模拟执行guest代码 ✔</li>
<li>如何在已有target构架基础上，修改出自己需要的新构架
<ul>
<li>如何在qemu中添加一个新的target构架：在/target/下新建转换为tcg的代码
<ul>
<li>如何让qemu加载添加的新构架</li>
<li>如何配置configure，可以正确的编译新增代码</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>下步工作：</p>
<ol>
<li>gen_intermediate_code函数分析</li>
<li>重新调整文档格式</li>
</ol>
<h1 id="%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">编译安装</h1>
<p>linux安装指导：https://wiki.qemu.org/Hosts/Linux</p>
<h2 id="%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD">代码下载</h2>
<p>下载页面：https://www.qemu.org/download/</p>
<p>git地址：https://git.qemu.org/?p=qemu.git， 或者：https://github.com/qemu/qemu</p>
<p>直接下载源码包编译会提示/tests等目录无法找到，需要从git clone</p>
<pre class="hljs"><code><div>git clone git://git.qemu-project.org/qemu.git
</div></code></pre>
<p>还需要执行<code>git submodule update</code>下载所有的git子模块</p>
<h2 id="%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85">安装依赖包</h2>
<p>代码下好后安装依赖包（ubuntu环境）</p>
<pre class="hljs"><code><div>sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev

sudo apt-get install libnfs-dev libiscsi-dev

sudo apt-get install git-email
sudo apt-get install libaio-dev libbluetooth-dev libbrlapi-dev libbz2-dev
sudo apt-get install libcap-dev libcap-ng-dev libcurl4-gnutls-dev libgtk-3-dev
sudo apt-get install libibverbs-dev libjpeg8-dev libncurses5-dev libnuma-dev
sudo apt-get install librbd-dev librdmacm-dev
sudo apt-get install libsasl2-dev libsdl1.2-dev libseccomp-dev libsnappy-dev libssh2-1-dev
sudo apt-get install libvde-dev libvdeplug-dev libvte-2.90-dev libxen-dev liblzo2-dev
sudo apt-get install valgrind xfslibs-dev 

</div></code></pre>
<h2 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91">代码编译</h2>
<pre class="hljs"><code><div>cd qemu
mkdir -p build
cd build
../configure --target-list=x86_64-softmmu,arm-softmmu --enable-debug --enable-debug-info # 只编译x86，arm版本
make
</div></code></pre>
<p>编译完成后运行</p>
<pre class="hljs"><code><div>./build/x86_64-softmmu/qemu-system-x86_64 -L pc-bios
</div></code></pre>
<p>如果依赖包安装没有装完全，编译时会没有gtk支持，运行时console显示<code>VNC server running on 127.0.0.1:5900</code>，在浏览器中打开，可以看见运行结果（一行文本）。可以运行<code>./build/x86_64-softmmu/qemu-system-x86_64 -L pc-bios -nographic</code>来在console中显示。
如果运行正常，会弹出一个虚拟机界面显示运行情况。</p>
<p>如果编译时指定了多个target，那么编译完成后，在build目录下会有以每个target-name命名的文件夹，这个文件夹中有一个qemu-system-{target-name}的文件，就是qemu针对不同target的执行程序。
在build目录下还会有几个qemu的通用工具：</p>
<ul>
<li>qemu-img：创建磁盘镜像，创建出的镜像格式有<a href="https://people.gnome.org/~markmc/qcow-image-format.html">qcow</a>、raw等等</li>
<li>qemu-ga：这是一个不利用网络实现 guest 和 host 之间交互的应用程序（使用 virtio-serial），运行在 guest 中。</li>
<li>qemu-io：这是一个执行 Qemu I/O 操作的命令行工具。</li>
<li>qemu-nbd：磁盘挂载工具。</li>
</ul>
<h1 id="%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95">使用GDB调试</h1>
<p>运行<code>gdb --args ./qemu-system-x86_64 -L pc-bios</code>（--args后面时qemu的运行命令，可以运行其他镜像）。然后可以使用gdb命令进行设置断电例如<code>break main</code>，在main函数设置断点。</p>
<p>GDB调试QEMU时经常遇到SIGUSR1与SIGUSR2后停下来，解决办法是执行命令：（网上说的，没遇到过）</p>
<pre class="hljs"><code><div>(gdb) handle SIGUSR1 SIGUSR2 noprint nostop
</div></code></pre>
<p><img src="gdb.png" alt="avatar"></p>
<h2 id="gdb%E5%91%BD%E4%BB%A4">gdb命令</h2>
<p>break 设断点，<code>break function_name</code>可以在对应函数设置断点
c 继续运行
bt 查看调用堆栈
layout src 看源码
info threads 查看线程</p>
<h2 id="%E5%8F%82%E8%80%83">参考</h2>
<p>https://www.cnblogs.com/woshiweige/p/4518431.html
https://www.cnblogs.com/shaohef/p/4532437.html</p>
<h1 id="%E4%BB%A3%E7%A0%81%E6%9E%84%E6%9E%B6">代码构架</h1>
<p>主要翻译自qemu detailed study，只有第7章，其他章节没找到。这篇文章应该是基于v0.13.x版本写的，和现有的构架有很多不同，所以有些部分做了修改。</p>
<p>其他资料：
<a href="https://blog.csdn.net/kids412kelly/article/details/52509670">各种姿势折腾 QEMU</a></p>
<p><a href="https://blog.csdn.net/dj0379/article/details/54926443">qemu源码架构</a></p>
<p><a href="https://blog.csdn.net/ivanx_cc/article/details/46122783">QEMU开发新的架构一</a></p>
<p><a href="https://blog.csdn.net/miaohongyu1/article/details/25954005">QEMU代码分析（1）－module_init()构造函数</a></p>
<p><a href="https://blog.csdn.net/Benjamin_Xu/article/details/72824904">关于qemu的二三事（5）————qemu源码分析之参数解析</a></p>
<h2 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h2>
<p>QEMU模拟的架构叫<code>target</code>，运行QEMU的系统架构叫<code>host</code>。虚拟机(target)代码的动态生成通过一个角TCG(Tiny Code Generator)的模块完成。TCG生成被虚拟机执行的代码，因此被TCG生成的代码叫做TCG的target（这里的target和前面qemu的target不一样）。</p>
<p><img src="构架.jpg" alt="avatar"></p>
<p>运行在虚拟处理器上的代码（操作系统+用户工具）叫做guest code。qemu解析guest code并将其转换为host specific code（这里保留host，guest的叫法，翻译成中文了容易混淆）。整个转换的任务包含两部分：</p>
<ul>
<li>首先是将一段target代码（就是guest code），也叫Translation Block(TB)，转换为TCG操作，一种与体系结构无关的中间代码。</li>
<li>然后这个TB对应的TCG根据host构架被转换成对应的host code，过程中会执行一些优化策略。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81%E6%9E%84%E6%9E%B6">代码构架</h2>
<ol>
<li>
<p>程序入口。主要的文件包括/vl.c,/cpus.c, /execall.c, /exec.c, /cpu-exec.c。<code>main</code>函数在/vl.c中，这个文件中的其他函数设置了虚拟机的其他参数，例如ram大小，cpu数量等。在虚拟机设置完成后，<code>main</code>函数会调用其他文件中的函数例如/cpus.c, /exec-all.c, /exec.c, /cpu-exec.c（execution branches out through files such as /cpus.c, /exec-all.c, /exec.c, /cpu-exec.c.） （main函数在2910行）</p>
</li>
<li>
<p>硬件模拟。所有模拟虚拟硬件的代码都放在/hw/中。</p>
</li>
<li>
<p>Guest (Target) Specific: 现在QEMU中已经模拟的处理器结构包括Alpha, ARM, Cris, i386, M68K, PPC, Sparc, Mips, MicroBlaze, S390X and SH4。将这些结构的TB转换为TCG操作的代码实现在/target/arch/中（添加新的结构应该就在这里），例如i386构架的代码在/target/i386/。这部分代码叫TCG前端（frontend of TCG）.。</p>
</li>
<li>
<p>Host (TCG) Specific: 从TCG操作中生成主机代码的代码在/tcg/host_arch/中，例如i386构架的代码在/tcg/i386/。这部分代码叫做TCG后端（backend of TCG）。</p>
</li>
<li>
<p>总结。</p>
<ul>
<li>
<p>/vl.c : 主模拟器循环，虚拟机设置和CPU执行（The main emulator loop, the virtual machine is  setup and CPUs are executed）。</p>
</li>
<li>
<p>/target/xyz/translate.c : 将客户端代码（客户端指令集）转换成与指令集构架无关的TCG操作。</p>
</li>
<li>
<p>/tcg/tcg.c : TCG的主循环.</p>
</li>
<li>
<p>/tcg/*/tcg-target.c :  将TCG操作转换为本机ISA代码。</p>
</li>
<li>
<p>/cpu-exec.c :  函数cpu-exec()寻找下一个TB，如果没有找打，则生成未找到TB的信号来产生一个新TB，最后执行生成的代码（应该是从TB-&gt;TCG，执行的是TCG？）。 cpu-exec() finds the next translation block (TB), if not found calls are made to generate the next TB  and finally to execute the generated code.</p>
</li>
</ul>
</li>
</ol>
<h2 id="tcg-%E5%8A%A8%E6%80%81%E7%BF%BB%E8%AF%91">TCG-动态翻译</h2>
<p>QEMU v0.9.1版本之前动态翻译都是由DynGen完成的。TB被DynGen转换为C代码，再由GCC将C代码转换为主机代码(host specific code)。为了解除与GCC的紧密联系，产生了一种新机制:TCG。</p>
<p>动态翻译使得代码再需要时才被转换。这个思想的主要目的是用最多的时间去执行生成后的代码而不是去生成代码(The idea was to spend the maximum time executing the generated code that executing the code generation)。每当从TB转换为代码（应该指的是TCG）后，这些代码会再执行前先被存储起来。多数时候相同的TB会被多次调用，这样通过本地引用（Locality Reference）可以重复使用之前转换好的代码。当指令缓存(code cache)填满时，整个缓存会被清空而不是使用LRU算法（least recently used，缓存淘汰算法）。</p>
<p><img src="构架2.PNG" alt="avatar"></p>
<blockquote>
<p>下面这一段说的是一般的编译过程，为了和tcg做对比</p>
</blockquote>
<p>在执行前编译器从源代码(source code)中生成结果代码(object code)。为了生成一个函数调用的结果代码，编译器（例如GCC）会在函数调用之前和之后插入一些特殊的汇编码（assembly code），这些汇编码称作Function Prologue and Epilogue。</p>
<p>如果体系结构（应该指的是target的结构）有一个基指针和一个栈指针，则Function Prologue通常执行以下操作：</p>
<ol>
<li>将当前基指针压入栈中，以便后续恢复。</li>
<li>将旧的基指针替换为当前栈指针，这样新栈会在旧栈的顶端产生。（应该是将基指针指向栈顶） Replaces the old base pointer with the current stack pointer such that the a new stack will be created on top of the old stack.</li>
<li>将栈指针向当前栈顶移动，给函数中的局部变量在栈中腾出存储空间。Moves the stack pointer further along the stack to make room in the current stack frame for the function's local variables.</li>
</ol>
<p>Function Epilogue恢复 function prologue执行的操作，并将控制权交会调用它的函数（ and returns control to the calling function，应该是只qemu的CPU调用循环）。它通常执行以下操作:</p>
<ol>
<li>将栈指针替换为当前基指针，这样栈指针就恢复成prologue之前的值。</li>
<li>将之前的基指针出栈，这样基指针就恢复成prologue之前的值。</li>
<li>弹出之前的程序指针并跳转，回到之前调用的函数。（Returns to the calling function, by popping the previous frame's program counter off the stack and jumping to it）</li>
</ol>
<p>TCG可以被看作一个生成object code的编译器。通过TCG生成的代码存储在缓存(code buffer)中，通过TCG的 Prologue和Epilogue功能来执行code buffer中的代码或者从中跳出（The execution control is passed to and from the code cache through TCG’s very on Prologue and Epilogue）。执行的流程见下图</p>
<p><img src="构架3.PNG" alt="avatar"></p>
<p>下面4幅图介绍了TCG是如何工作的：</p>
<p><img src="构架4.PNG" alt="avatar">
<img src="构架5.PNG" alt="avatar">
<img src="构架6.PNG" alt="avatar">
<img src="构架7.PNG" alt="avatar"></p>
<h2 id="tb%E9%93%BE%EF%BC%88chaining-of-tbs%EF%BC%89">TB链（Chaining of TBs）</h2>
<p>从code cache返回到静态代码（QEMU程序），或者跳转到code cache通常都十分缓慢。为了解决这一问题，QEMU将每一个TB都链接到下一个TB。这样在执行完一个TB后会直接执行下一个TB而不是返回静态代码（QEMU程序）。当不存在链接(no chaining)的TB1执行完返回静态代码后，紧接着发现、转换、执行了TB2，那么当TB2返回时就会被自动的链接到TB1上。这样下次TB1执行完成后就会直接执行TB2，而不返回静态代码。如下图所示。</p>
<p><img src="TB_chain.PNG" alt="avatar"></p>
<h2 id="%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">执行过程</h2>
<p>qemu基本的执行流程可以参加下图，图中最上部分表格表示所对应的文件位置，绿色方框代表函数，浅蓝色方框代表执行流程，红色连接线代表尚未完全清楚的调用关系，蓝色连接线代表程序执行流程，绿色虚线代表将函数执行的过程展开描述。
<img src="执行流程.svg" alt="avatar"></p>
<h3 id="main-vlc">main <code>{/vl.c}</code></h3>
<p>main函数解析命令行输入参数，本根据参数设置虚拟机(VM)，例如ram，磁盘大小，启动盘等。当VM设置完成后，main()调用main_loop()。
qemu_init_cpu_list();
qemu_init_cpu_loop();</p>
<p>main函数和主要的执行过程cpu_exec之间的调用关系并没有完全明确，通过gdb调试，可以得到如下的调用堆栈：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#</span><span class="bash">0  0x0000555555850801 <span class="hljs-keyword">in</span> qemu_tcg_init_vcpu (cpu=0x555556b54fc0) at /home/liwb/qemu/cpus.c:1854</span>
<span class="hljs-meta">#</span><span class="bash">1  0x0000555555850df7 <span class="hljs-keyword">in</span> qemu_init_vcpu (cpu=0x555556b54fc0) at /home/liwb/qemu/cpus.c:2007</span>
<span class="hljs-meta">#</span><span class="bash">2  0x000055555594ca35 <span class="hljs-keyword">in</span> x86_cpu_realizefn (dev=0x555556b54fc0, errp=0x7fffffffd780) at /home/liwb/qemu/target/i386/cpu.c:4996</span>
<span class="hljs-meta">#</span><span class="bash">3  0x0000555555a7fd4d <span class="hljs-keyword">in</span> device_set_realized (obj=0x555556b54fc0, value=<span class="hljs-literal">true</span>, errp=0x7fffffffd958) at /home/liwb/qemu/hw/core/qdev.c:826</span>
<span class="hljs-meta">#</span><span class="bash">4  0x0000555555c6e4d3 <span class="hljs-keyword">in</span> property_set_bool (obj=0x555556b54fc0, v=0x55555699a3a0, name=0x555555ebb4c0 <span class="hljs-string">"realized"</span>, opaque=0x555556a2ad60, errp=0x7fffffffd958)</span>
    at /home/liwb/qemu/qom/object.c:1984
<span class="hljs-meta">#</span><span class="bash">5  0x0000555555c6c74f <span class="hljs-keyword">in</span> object_property_set (obj=0x555556b54fc0, v=0x55555699a3a0, name=0x555555ebb4c0 <span class="hljs-string">"realized"</span>, errp=0x7fffffffd958) at /home/liwb/qemu/qom/object.c:1176</span>
<span class="hljs-meta">#</span><span class="bash">6  0x0000555555c6f810 <span class="hljs-keyword">in</span> object_property_set_qobject (obj=0x555556b54fc0, value=0x5555569ea9e0, name=0x555555ebb4c0 <span class="hljs-string">"realized"</span>, errp=0x7fffffffd958)</span>
    at /home/liwb/qemu/qom/qom-qobject.c:27
<span class="hljs-meta">#</span><span class="bash">7  0x0000555555c6ca34 <span class="hljs-keyword">in</span> object_property_set_bool (obj=0x555556b54fc0, value=<span class="hljs-literal">true</span>, name=0x555555ebb4c0 <span class="hljs-string">"realized"</span>, errp=0x7fffffffd958) at /home/liwb/qemu/qom/object.c:1242</span>
<span class="hljs-meta">#</span><span class="bash">8  0x0000555555916215 <span class="hljs-keyword">in</span> pc_new_cpu (typename=0x555555ebbe6c <span class="hljs-string">"qemu64-x86_64-cpu"</span>, apic_id=0, errp=0x5555567680d8 &lt;error_fatal&gt;) at /home/liwb/qemu/hw/i386/pc.c:1107</span>
<span class="hljs-meta">#</span><span class="bash">9  0x0000555555916480 <span class="hljs-keyword">in</span> pc_cpus_init (pcms=0x555556870950) at /home/liwb/qemu/hw/i386/pc.c:1155</span>
<span class="hljs-meta">#</span><span class="bash">10 0x000055555591aa50 <span class="hljs-keyword">in</span> pc_init1 (machine=0x555556870950, host_type=0x555555ebc844 <span class="hljs-string">"i440FX-pcihost"</span>, pci_type=0x555555ebc83d <span class="hljs-string">"i440FX"</span>)</span>
    at /home/liwb/qemu/hw/i386/pc_piix.c:153
<span class="hljs-meta">#</span><span class="bash">11 0x000055555591b659 <span class="hljs-keyword">in</span> pc_init_v3_0 (machine=0x555556870950) at /home/liwb/qemu/hw/i386/pc_piix.c:438</span>
<span class="hljs-meta">#</span><span class="bash">12 0x0000555555a882fc <span class="hljs-keyword">in</span> machine_run_board_init (machine=0x555556870950) at /home/liwb/qemu/hw/core/machine.c:830</span>
<span class="hljs-meta">#</span><span class="bash">13 0x00005555559d5aa4 <span class="hljs-keyword">in</span> main (argc=3, argv=0x7fffffffde48, envp=0x7fffffffde68) at /home/liwb/qemu/vl.c:4516</span>
</div></code></pre>
<p>首先是main函数启动后，在进行一系列初始化的过程中调用了qemu_tcg_init_vcpu。这里可以发现这些函数之间的调用大多是通过函数指针进行的，但是没有找到具体给函数指针赋值的位置，因此也无从确认函数之间的调用关系，只能通过调用堆栈印证。</p>
<p>然后观察cpu_exec的调用堆栈，可以推断cpu_exec和qemu_tcg_rr_cpu_thread_fn运行同一个线程中，这个线程不同于main函数所在线程，这个线程应该就是在qemu_tcg_init_vcpu中创建的。</p>
<pre class="hljs"><code><div>Thread 6 "qemu-system-x86" hit Breakpoint 4, cpu_exec (cpu=0x555556b537c0) at /home/liwb/qemu/accel/tcg/cpu-exec.c:656
(gdb) bt
<span class="hljs-meta">#</span><span class="bash">0  0x00005555558aab2c <span class="hljs-keyword">in</span> cpu_exec (cpu=0x555556b537c0) at /home/liwb/qemu/accel/tcg/cpu-exec.c:656</span>
<span class="hljs-meta">#</span><span class="bash">1  0x000055555584fbb6 <span class="hljs-keyword">in</span> tcg_cpu_exec (cpu=0x555556b537c0) at /home/liwb/qemu/cpus.c:1363</span>
<span class="hljs-meta">#</span><span class="bash">2  0x000055555584fe0c <span class="hljs-keyword">in</span> qemu_tcg_rr_cpu_thread_fn (arg=0x555556b537c0) at /home/liwb/qemu/cpus.c:1463</span>
<span class="hljs-meta">#</span><span class="bash">3  0x0000555555dac9b7 <span class="hljs-keyword">in</span> qemu_thread_start (args=0x555556a73fe0) at /home/liwb/qemu/util/qemu-thread-posix.c:504</span>
<span class="hljs-meta">#</span><span class="bash">4  0x00007ffff25166db <span class="hljs-keyword">in</span> start_thread (arg=0x7fffc89d6700) at pthread_create.c:463</span>
<span class="hljs-meta">#</span><span class="bash">5  0x00007ffff223f88f <span class="hljs-keyword">in</span> <span class="hljs-built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span>
</div></code></pre>
<h3 id="mainloop-vlc">main_loop <code>{/vl.c}</code></h3>
<p>[Function main_loop initially calls qemu_main_loop_start() and then does infinite looping of cpu_exec_all() and profile_getclock() within a do-while for which the condition is vm_can_run(). The infinite for-loop continues with checking some VM halting situations like qemu_shutdown_requested(), qemu_powerdown_requested(), qemu_vmstop_requested() etc. These halting conditions will not be investigated further.]</p>
<p>上文是早期版本的函数解释，v3.0已经不是这个结构，代码如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main_loop</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_PROFILER</span>
    <span class="hljs-keyword">int64_t</span> ti;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-keyword">while</span> (!main_loop_should_exit()) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_PROFILER</span>
        ti = profile_getclock();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        main_loop_wait(<span class="hljs-literal">false</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_PROFILER</span>
        dev_time += profile_getclock() - ti;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    }
}
</div></code></pre>
<p>可以发现，出去profiler后，内部就是一个while循环，调用<code>main_loop_wait</code></p>
<ol>
<li>main_loop_should_exit()检查是否退出循环，main_loop_should_exit()中检查了runstate_check(),qemu_debug_requested(),qemu_suspend_requested(),qemu_shutdown_requested(),qemu_kill_report(),qapi_event_send_shutdown()...等信号</li>
<li>main_loop_wait(){/include/qemu/main-loop.h,/util/main-loop.c}是循环执行内容。
调用函数
<ul>
<li>main_loop_wait()
<ul>
<li>g_array_set_size() 未找到定义位置，g_代表全局函数？，有很多g_array_xxx()，处理数组用的？</li>
<li>slirp_pollfds_fill() {slirp/libslirp.h, slirp/slirp.c}</li>
<li>qemu_soonest_timeout() {/include/qemu/timer.h} Calculates the soonest of two timeout values. -1 means infinite, which is later than any other value.
<ul>
<li>timerlistgroup_deadline_ns() {/include/qemu/timer.h} Determine the deadline of the soonest timer to expire associated with any timer list linked to the timer list group. Only clocks suitable for deadline calculation are included.</li>
</ul>
</li>
<li>os_host_main_loop_wait(){/util/main-loop.c} 根据操作系统不同，有2个函数。</li>
<li>slirp_pollfds_poll()</li>
<li>qemu_start_warp_timer() {/cpus.c}</li>
<li>qemu_clock_run_all_timers() {/include/qemu/timer.h} Run all the timers associated with the default timer list of every clock.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>并不清楚在main_loop_wait中具体的作用。</p>
<h3 id="xxxcpurealizefn-targetxxxcpuc">xxx_cpu_realizefn() <code>{/target/xxx/cpu.c}</code></h3>
<p>每个target下都有这个函数，具体内容各不相同，但都先后效用了下面两个函数</p>
<ol>
<li>cpu_exec_realizefn 猜测应该是cpu实例化的函数</li>
<li>qemu_init_vcpu 初始化vcpu，vcpu是虚拟cpu？cpu指的是target的cpu，那么vcpu是指运行在实体机上的cpu被用来执行tcg指令的？</li>
<li>cpu_reset cpu重置</li>
</ol>
<h3 id="cpuexecrealizefn-execc">cpu_exec_realizefn() <code>{/exec.c}</code></h3>
<ol>
<li>cpu_list_add(cpu); {/cpu-commons.c} 将当前cpu添加到cpulist， 给cpu-&gt;cpu_index = cpu_get_free_index()赋值了一个新的序号</li>
<li>if (tcg_enabled() &amp;&amp; !tcg_target_initialized)
<ul>
<li>{/qemo-common.h}中的一个宏定义，如果启用了tcg则<code>#define tcg_enabled() (tcg_allowed)</code></li>
<li>tcg_allowed是一个全局变量，在tcg_exec_init{/accel/tcg/translate-all.c}中赋值为true，该函数在main()中被调用。</li>
</ul>
</li>
<li>cc-&gt;tcg_initialize();
<ul>
<li>cc是CPUClass{/include/qom/cpu.h}类型，详情可以参见其中注释</li>
<li>tcg_initialize是一个虚函数，在不同的target中被赋值为不同的函数。</li>
<li>在openrisc中的tcg_initialize是openrisc_translate_init{/target/openrisc/translate.c}，函数中定义了许多TCGv类型的全局变量，应该是供tcg调用的</li>
<li>TCGv{/tcg/tcg.h}类型，根据系统不同为32或者64位integer
<blockquote>
<p>Note that there is no definition of the structs TCGv_i32_d etc anywhere. This is deliberate, because the values we store in variables of type TCGv_i32 are not really pointers-to-structures. They're just small integers, but keeping them in pointer types like this means that the compiler will complain if you accidentally pass a TCGv_i32 to a  function which takes a TCGv_i64, and so on. Only the internals of TCG need to care about the actual contents of the types.</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="qemuinitvcpu-cpusc">qemu_init_vcpu() <code>{/cpus.c}</code></h3>
<ol>
<li>CPUState *cpu, CPUState{/include/qom/cpu.h}是<code>State of one CPU core or thread.</code></li>
<li>cpu-&gt;as 到第一个AddressSpace的指针，<code>Pointer to the first AddressSpace, for the convenience of targets which only have a single AddressSpace</code></li>
<li>if (!cpu-&gt;as) {...} 如果没有AddressSpace，那么将cpu的AddressSpace数设为1，然后新建一个AddressSpace。</li>
<li>根据kvm_enabled、hax_enabled、hvf_enabled、tcg_enabled、whpx_enabled选择init方式，这里调用了qemu_tcg_init_vcpu()</li>
<li>while (!cpu-&gt;created) {...qemu_cond_wait...} 等待直到cpu-&gt;created</li>
</ol>
<h3 id="qemutcginitvcpu-cpusc">qemu_tcg_init_vcpu <code>{/cpus.c}</code></h3>
<p>观察qemu_tcg_init_vcpu函数的代码，可以找到如下段落：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (qemu_tcg_mttcg_enabled()) {
    <span class="hljs-comment">/* create a thread per vCPU with TCG (MTTCG) */</span>
    parallel_cpus = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">snprintf</span>(thread_name, VCPU_THREAD_NAME_SIZE, <span class="hljs-string">"CPU %d/TCG"</span>,
            cpu-&gt;cpu_index);

    qemu_thread_create(cpu-&gt;thread, thread_name, qemu_tcg_cpu_thread_fn,
                        cpu, QEMU_THREAD_JOINABLE);

} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* share a single thread for all cpus with TCG */</span>
    <span class="hljs-built_in">snprintf</span>(thread_name, VCPU_THREAD_NAME_SIZE, <span class="hljs-string">"ALL CPUs/TCG"</span>);
    qemu_thread_create(cpu-&gt;thread, thread_name,
                        qemu_tcg_rr_cpu_thread_fn,
                        cpu, QEMU_THREAD_JOINABLE);

    single_tcg_halt_cond = cpu-&gt;halt_cond;
    single_tcg_cpu_thread = cpu-&gt;thread;
}
</div></code></pre>
<p>这些代码根据模式不同使用了单线程或者多线程tcg。然后通过qemu_thread_create函数创建了tcg的运行线程。</p>
<h3 id="qemutcgrrcputhreadfn-cpusc">qemu_tcg_rr_cpu_thread_fn <code>{/cpus.c}</code></h3>
<ol>
<li>
<p>函数注释</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* Single-threaded TCG
*
* In the single-threaded case each vCPU is simulated in turn. If
* there is more than a single vCPU we create a simple timer to kick
* the vCPU and ensure we don't get stuck in a tight loop in one vCPU.
* This is done explicitly rather than relying on side-effects
* elsewhere.
*/</span>
</div></code></pre>
</li>
<li>
<p>初始化</p>
<ul>
<li>assert(tcg_enabled()); 确保tcg启用</li>
<li>rcu_register_thread(); {/util/rcu.c} 注册rcg,代码中注释：Reader thread registration，不清楚rcu是什么</li>
<li>tcg_register_thread();<pre class="hljs"><code><div><span class="hljs-comment">/*
* All TCG threads except the parent (i.e. the one that called tcg_context_init
* and registered the target's TCG globals) must register with this function
* before initiating translation.
*
* In user-mode we just point tcg_ctx to tcg_init_ctx. See the documentation
* of tcg_region_init() for the reasoning behind this.
*
* In softmmu each caller registers its context in tcg_ctxs[]. Note that in
* softmmu tcg_ctxs[] does not track tcg_ctx_init, since the initial context
* is not used anymore for translation once this function is called.
*
* Not tracking tcg_init_ctx in tcg_ctxs[] in softmmu keeps code that iterates
* over the array (e.g. tcg_code_size() the same for both softmmu and user-mode.
*/</span>
</div></code></pre>
</li>
<li>while (first_cpu-&gt;stopped) {} 应该是循环等待所有CPU初始化完成<pre class="hljs"><code><div><span class="hljs-comment">/* wait for initial kick-off after machine start */</span>
<span class="hljs-keyword">while</span> (first_cpu-&gt;stopped) {
    qemu_cond_wait(first_cpu-&gt;halt_cond, &amp;qemu_global_mutex);

    <span class="hljs-comment">/* process any pending work */</span>
    CPU_FOREACH(cpu) {
        current_cpu = cpu;
        qemu_wait_io_event_common(cpu);
    }
}
</div></code></pre>
这里的first_cpu {/include/qom/cpu.h}是一个宏定义，从CPU队列里得到第一个CPU，<code>#define first_cpu QTAILQ_FIRST(&amp;cpus)</code>。current_cpu{/exec.c} 是一个全局变量 <code>__thread CPUState *current_cpu;</code>，其中的<code>__thread</code>没有查到是什么意思</li>
</ul>
</li>
<li>
<p>start_tcg_kick_timer() 函数注释中说的<code>don't get stuck in a tight loop in one vCPU</code>所用到的timer，这里是timer启动，后面如何判断不会超时的代码没有发现。</p>
</li>
<li>
<p>while(1)循环，应该会反复执行，没有发现break的条件</p>
<ul>
<li>一些mutex lock操作，不清楚具体作用</li>
<li>将当前CPU设置为first_cpu</li>
<li>循环所有的CPU
<ul>
<li>atomic_mb_set(&amp;tcg_current_rr_cpu, cpu);</li>
<li>if (cpu_can_run(cpu)) 如果当前cpu可以执行
<ul>
<li>r = tcg_cpu_exec(cpu); 执行tcg代码</li>
<li>返回值r的相关宏定义在{/include/exec/cpu-all.h}</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_INTERRUPT 	0x10000 <span class="hljs-comment">/* async interruption */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_HLT        0x10001 <span class="hljs-comment">/* hlt instruction reached */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_DEBUG      0x10002 <span class="hljs-comment">/* cpu stopped after a breakpoint or singlestep */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_HALTED     0x10003 <span class="hljs-comment">/* cpu is halted (waiting for external event) */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_YIELD      0x10004 <span class="hljs-comment">/* cpu wants to yield timeslice to another */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXCP_ATOMIC     0x10005 <span class="hljs-comment">/* stop-the-world and emulate atomic */</span></span>
</div></code></pre>
<ul>
<li>if (r == EXCP_DEBUG) cpu_handle_guest_debug() {/cpus.c} 处理debug相关</li>
<li>if (r == EXCP_ATOMIC) cpu_exec_step_atomic() {/accel/tcg/cpu-exec.c} 原子性相关，不清楚具体含义</li>
</ul>
</li>
<li>if (cpu-&gt;stop)
<ul>
<li>if (cpu-&gt;unplug) cpu = CPU_NEXT(cpu);</li>
<li>break 跳出循环，不清楚为什么一个cpu停止就要跳出所有cpu的执行循环</li>
</ul>
</li>
<li>cpu = CPU_NEXT(cpu); 执行下一个cpu</li>
</ul>
</li>
<li>不清楚这些代码在干什么<pre class="hljs"><code><div>atomic_set(&amp;tcg_current_rr_cpu, <span class="hljs-literal">NULL</span>);

<span class="hljs-keyword">if</span> (cpu &amp;&amp; cpu-&gt;exit_request) {
    atomic_mb_set(&amp;cpu-&gt;exit_request, <span class="hljs-number">0</span>);
}

qemu_tcg_rr_wait_io_event(cpu ? cpu : QTAILQ_FIRST(&amp;cpus));
deal_with_unplugged_cpus();
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>rcu_unregister_thread() 和初始化时注册rcu线程对应</p>
</li>
</ol>
<h3 id="tcgcpuexec-cpusc">tcg_cpu_exec <code>{/cpus.c}</code></h3>
<ol>
<li>cpu_exec_start(cpu);{/cpu-common.c}<pre class="hljs"><code><div><span class="hljs-comment">/* Wait for exclusive ops to finish, and begin cpu execution. */</span>
</div></code></pre>
</li>
<li>ret = cpu_exec(cpu); {/accel/tcg/cpu-exec.c} 主要执行循环</li>
<li>cpu_exec_end(cpu);{/cpu-common.c}<pre class="hljs"><code><div><span class="hljs-comment">/* Mark cpu as not executing, and release pending exclusive ops.  */</span>
</div></code></pre>
</li>
</ol>
<h3 id="cpuhandleguestdebug">cpu_handle_guest_debug</h3>
<p>todo</p>
<h3 id="cpuexecstepatomic">cpu_exec_step_atomic</h3>
<p>todo</p>
<h3 id="cpuexec-acceltcgcpu-execc">cpu_exec <code>{/accel/tcg/cpu-exec.c}</code></h3>
<p>todo: here</p>
<ol>
<li>输入参数时<code>CPUState</code>{/include/qom/cpu.h}</li>
<li>cc-&gt;cpu_exec_enter(cpu); Callback for cpu_exec preparation. 在cpu_class_init{/qom/cpu.c}中：<code>k-&gt;cpu_exec_enter = cpu_common_noop</code>。cpu_common_noop是一个空函数。</li>
<li>if (sigsetjmp(cpu-&gt;jmp_env, 0) != 0) prepare setjmp context for exception handling</li>
<li>while (!cpu_handle_exception(cpu, &amp;ret)) if an exception is pending, we execute it here
<ul>
<li>while (!cpu_handle_interrupt(cpu, &amp;last_tb)) 处理中断
<ul>
<li>tb = tb_find(cpu, last_tb, tb_exit, cflags); 查找tb</li>
<li>cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit); 执行tb</li>
<li>align_clocks(&amp;sc, cpu); 对齐host和虚拟时钟<pre class="hljs"><code><div><span class="hljs-comment">/* Try to align the host and virtual clocks if the guest is in advance */</span>
</div></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>cc-&gt;cpu_exec_exit(cpu); 和cpu_exec_enter一样，也是cpu_common_noop，空函数。</li>
</ol>
<h3 id="cpuhandleexception-acceltcgcpu-execc">cpu_handle_exception <code>{/accel/tcg/cpu-exec.c}</code></h3>
<p>todo</p>
<h3 id="cpuhandleinterrupt-acceltcgcpu-execc">cpu_handle_interrupt <code>{/accel/tcg/cpu-exec.c}</code></h3>
<p>todo</p>
<h3 id="cpuloopexectb-acceltcgcpu-execc">cpu_loop_exec_tb <code>{/accel/tcg/cpu-exec.c}</code></h3>
<p>执行tb生成的host代码，主要调用的函数</p>
<ul>
<li>cpu_tb_exec</li>
<li>cpu_exec_nocache</li>
</ul>
<h3 id="tbfind-acceltcgcpu-execc">tb_find <code>{/accel/tcg/cpu-exec.c}</code></h3>
<ol>
<li>tb = tb_lookup__cpu_state(cpu, &amp;pc, &amp;cs_base, &amp;flags, cf_mask); 查找对应的tb</li>
<li>如果未找到，则生成tb，再将生成的tb加入到lookup表中。<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (tb == <span class="hljs-literal">NULL</span>) {
    mmap_lock();
    tb = tb_gen_code(cpu, pc, cs_base, flags, cf_mask);
    mmap_unlock();
    <span class="hljs-comment">/* We add the TB in the virtual pc hash table for the fast lookup */</span>
    atomic_set(&amp;cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);
}
</div></code></pre>
</li>
<li>处理跳转相关，这里的last_tb是再cpu_exec中经过cpu_handle_interrupt(cpu, &amp;last_tb)处理过的，tb_exit=0， 不清除具体功能<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (last_tb &amp;&amp; !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {
    tb_add_jump(last_tb, tb_exit, tb);
}
</div></code></pre>
</li>
</ol>
<h3 id="tblookupcpustate-includeexectblookuph">tb_lookup__cpu_state <code>{/include/exec/tb_lookup.h}</code></h3>
<ol>
<li>cpu_get_tb_cpu_state(env, pc, cs_base, flags) 调用cpu_get_tb_cpu_state，根据cpu不同，执行不同函数，获取当前cpu的PC, Flags等等。</li>
<li>然后根据pc值找到对应的tb<pre class="hljs"><code><div>hash = tb_jmp_cache_hash_func(*pc);
tb = atomic_rcu_read(&amp;cpu-&gt;tb_jmp_cache[hash]);
</div></code></pre>
<ul>
<li><code>tb_jmp_cache_hash_func</code>是通过pc值从hash表中找到索引的函数。(This is a hash function to find offset of TB in tb_jmp_cache using the PC as key)</li>
<li>当一个tb存储在tb_jmp_cache中时，可以直接通过通过pc值从hash表中找到，然后代码会检查找到的tb的有效性(The code then follows to check the validity of the found TB)？</li>
</ul>
</li>
<li>检查tb有效性，如果有效则直接返回tb<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (likely(tb &amp;&amp;
        tb-&gt;pc == *pc &amp;&amp;
        tb-&gt;cs_base == *cs_base &amp;&amp;
        tb-&gt;flags == *flags &amp;&amp;
        tb-&gt;trace_vcpu_dstate == *cpu-&gt;trace_dstate &amp;&amp;
        (tb_cflags(tb) &amp; (CF_HASH_MASK | CF_INVALID)) == cf_mask)) {
    <span class="hljs-keyword">return</span> tb;
}
</div></code></pre>
</li>
<li>否则更慢速查找tb<pre class="hljs"><code><div>tb = tb_htable_lookup(cpu, *pc, *cs_base, *flags, cf_mask);
</div></code></pre>
</li>
<li>如果仍未找到，返回NULL，否则将找到的tb加入tb_jmp_cache，方便下次查找，再返回tb<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (tb == <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
atomic_set(&amp;cpu-&gt;tb_jmp_cache[hash], tb);
<span class="hljs-keyword">return</span> tb;
</div></code></pre>
</li>
</ol>
<h3 id="tbhtablelookup-acceltcgcpu-execc">tb_htable_lookup <code>{/accel/tcg/cpu-exec.c}</code></h3>
<p>更慢速查找tb的函数</p>
<ol>
<li>phys_pc是guest上的物理地址，用来查找下一个TB。phys_pc should be the physical memory address of  the Guest OS’s PC, and it is used to find the next TB through a hash function.<pre class="hljs"><code><div>phys_pc = get_page_addr_code(desc.env, pc);
</div></code></pre>
</li>
<li>phys_pc计算hash，再通过hash查找tb并返回<pre class="hljs"><code><div>h = tb_hash_func(phys_pc, pc, flags, cf_mask, *cpu-&gt;trace_dstate);
<span class="hljs-keyword">return</span> qht_lookup_custom(&amp;tb_ctx.htable, &amp;desc, h, tb_lookup_cmp);
</div></code></pre>
</li>
</ol>
<h3 id="struct-translationblock-includeexecexec-allh">struct TranslationBlock <code>{/include/exec/exec-all.h}</code></h3>
<ol>
<li>下面是早期版本的解析，现在版本已经不同。
<blockquote>
<p>Structure TranslationBlock contains the following; PC, CS_BASE, Flags corresponding to this TB, tc_ptr (a pointer to the translated code of this TB), tb_next_offset[2], tb_jmp_offset[2] (both to find the TBs chained to this TB. ie. the TB that follows this TB), *jmp_next[2], *jmp_first (points to the TBs that jump into this TB).</p>
</blockquote>
</li>
<li>TB包含以下内容：
<ul>
<li>这个TB对应的PC, CS_BASE, Flags；</li>
<li>struct tb_tc tc; Translation Cache相关的指针<pre class="hljs"><code><div><span class="hljs-comment">/*
* Translation Cache-related fields of a TB.
* This struct exists just for convenience; we keep track of TB's in a binary
* search tree, and the only fields needed to compare TB's in the tree are
* @ptr and @size.
* Note: the address of search data can be obtained by adding @size to @ptr.
*/</span>
</div></code></pre>
</li>
<li>指向代码页的指针，这里应该是指的target代码？<pre class="hljs"><code><div><span class="hljs-comment">/* first and second physical page containing code. The lower bit
of the pointer tells the index in page_next[].
The list is protected by the TB's page('s) lock(s) */</span>
<span class="hljs-keyword">uintptr_t</span> page_next[<span class="hljs-number">2</span>];
<span class="hljs-keyword">tb_page_addr_t</span> page_addr[<span class="hljs-number">2</span>];
</div></code></pre>
</li>
<li>用来跳转到其他TB的指针，最多支持两个跳转方向。<pre class="hljs"><code><div><span class="hljs-comment">/* The following data are used to directly call another TB from
* the code of this one. This can be done either by emitting direct or
* indirect native jump instructions. These jumps are reset so that the TB
* just continues its execution. The TB can be linked to another one by
* setting one of the jump targets (or patching the jump instruction). Only
* two of such jumps are supported.
*/</span>
<span class="hljs-keyword">uint16_t</span> jmp_reset_offset[<span class="hljs-number">2</span>]; <span class="hljs-comment">/* offset of original jump target */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TB_JMP_RESET_OFFSET_INVALID 0xffff <span class="hljs-comment">/* indicates no jump generated */</span></span>
<span class="hljs-keyword">uintptr_t</span> jmp_target_arg[<span class="hljs-number">2</span>];  <span class="hljs-comment">/* target address or offset */</span>
</div></code></pre>
按照注释的描述，jmp_reset_offset是在跳转reset时使用的，应该是跳转到这个TB的TB地址。但是后面又有一组指针来专门存储incoming jumps，这样来看，reset的时候就时跳回当前TB，但这样jmp_reset_offset的含义就很奇怪，因为没有必要存储自己的地址。</li>
<li>jmp_list_head是所有incoming jumps组成的列表的头（很奇怪，为什么要用链表来存这些？），链表用NULL结尾。每个TB有两个跳转方向，因此就可能出现在两个list中，这些list的入口存储在jmp_list_next[2]中，指针的最低有效位用来表示哪个list是真正指向（下一个）TB的。jmp_dest[]用来存储所有的outgoing jump，是tagged指针（含义？）<pre class="hljs"><code><div><span class="hljs-comment">/*
* Each TB has a NULL-terminated list (jmp_list_head) of incoming jumps.
* Each TB can have two outgoing jumps, and therefore can participate
* in two lists. The list entries are kept in jmp_list_next[2]. The least
* significant bit (LSB) of the pointers in these lists is used to encode
* which of the two list entries is to be used in the pointed TB.
*
* List traversals are protected by jmp_lock. The destination TB of each
* outgoing jump is kept in jmp_dest[] so that the appropriate jmp_lock
* can be acquired from any origin TB.
*
* jmp_dest[] are tagged pointers as well. The LSB is set when the TB is
* being invalidated, so that no further outgoing jumps from it can be set.
*
* jmp_lock also protects the CF_INVALID cflag; a jump must not be chained
* to a destination TB that has CF_INVALID set.
*/</span>
<span class="hljs-keyword">uintptr_t</span> jmp_list_head;
<span class="hljs-keyword">uintptr_t</span> jmp_list_next[<span class="hljs-number">2</span>];
<span class="hljs-keyword">uintptr_t</span> jmp_dest[<span class="hljs-number">2</span>];
</div></code></pre>
整个这段注释都没有十分的理解，和上一段一样，感觉不清楚在说什么。</li>
</ul>
</li>
</ol>
<h3 id="tbgencode-acceltcgtranslateallc">tb_gen_code <code>{/accel/tcg/translate_all.c}</code></h3>
<ol>
<li>创建一个新tb<pre class="hljs"><code><div>phys_pc = get_page_addr_code(env, pc);    
tb = tb_alloc(pc);
</div></code></pre>
<ul>
<li>Function tb_gen_code starts with allocating   ( tb_alloc() ) a new TB, the PC for the TB is found from the PC of CPUState using get_page_addr_code().</li>
<li>get_page_addr_code{/include/exec/exec-all.h} 函数定义如下，<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> tb_page_addr_t <span class="hljs-title">get_page_addr_code</span><span class="hljs-params">(CPUArchState *env1, target_ulong addr)</span>
</span>{
    <span class="hljs-keyword">return</span> addr;
}
</div></code></pre>
相当于函数直接返回了pc，并没有发现phys_pc在哪里被使用，tb_alloc时使用的还是当前pc值。</li>
</ul>
</li>
<li>检查新建从tb有效性，如果无效则直接生成中断，并退出<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (unlikely(!tb)) {
    <span class="hljs-comment">/* flush must be done */</span>
    tb_flush(cpu);
    mmap_unlock();
    <span class="hljs-comment">/* Make the execution loop process the flush as soon as possible.  */</span>
    cpu-&gt;exception_index = EXCP_INTERRUPT;
    cpu_loop_exit(cpu);
}
</div></code></pre>
</li>
<li>给新建的tb赋值<pre class="hljs"><code><div>gen_code_buf = tcg_ctx-&gt;code_gen_ptr;
tb-&gt;tc.ptr = gen_code_buf;
tb-&gt;pc = pc;
tb-&gt;cs_base = cs_base;
tb-&gt;flags = flags;
tb-&gt;cflags = cflags;
tb-&gt;trace_vcpu_dstate = *cpu-&gt;trace_dstate;
tcg_ctx-&gt;tb_cflags = cflags;
</div></code></pre>
其中tcg_ctx的声明为<code>extern __thread TCGContext *tcg_ctx;</code>{/tcg/tcg.h}，没有找到定义的地方。</li>
<li>tcg_func_start() {/tcg/tcg.c}，为tcg_ctx分配了内存，还有些初始化操作，其他功能未知。</li>
<li>将target代码转换到tcg代码，前后分别给tcg_ctx-&gt;cpu赋值不清楚意义何在<pre class="hljs"><code><div>tcg_ctx-&gt;cpu = ENV_GET_CPU(env);
gen_intermediate_code(cpu, tb);
tcg_ctx-&gt;cpu = <span class="hljs-literal">NULL</span>;
</div></code></pre>
</li>
<li>trace_translate_block(tb, tb-&gt;pc, tb-&gt;tc.ptr)
未找到...</li>
<li>tcg_gen_code(tcg_ctx, tb) {/tcg/tcg.c} 从tcg转换为host执行的代码</li>
<li>tb_link_page(tb, phys_pc, phys_page2) <code>{/accel/tcg/translate_all.c}</code><pre class="hljs"><code><div><span class="hljs-comment">/* add a new TB and link it to the physical page tables. phys_page2 is
* (-1) to indicate that only one page contains the TB.
*
* Called with mmap_lock held for user-mode emulation.
*
* Returns a pointer @tb, or a pointer to an existing TB that matches @tb.
* Note that in !user-mode, another thread might have already added a TB
* for the same block of guest code that @tb corresponds to. In that case,
* the caller should discard the original @tb, and use instead the returned TB.
*/</span>
</div></code></pre>
</li>
<li>tcg_tb_insert(tb) <code>{/tcg/tcg.c}</code></li>
</ol>
<h3 id="genintermediatecode-targetxxxtranslatec">gen_intermediate_code {/target/xxx/translate.c}</h3>
<p>应该是转换guest-&gt;tcg代码。每个target下均有该函数，将target代码转换为tcg代码（generate intermediate code for basic block 'tb'）</p>
<ol>
<li>
<p>在translate.c文件中会定义一个xxx_xxx_ops的变量：</p>
<p>TranslatorOps{/accel/tcg/translater.h}结构定义如下。<code>Disas</code>应该是disassembly的缩写。</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
* TranslatorOps:
* @init_disas_context:
*      Initialize the target-specific portions of DisasContext struct.
*      The generic DisasContextBase has already been initialized.
*
* @tb_start:
*      Emit any code required before the start of the main loop,
*      after the generic gen_tb_start().
*
* @insn_start:
*      Emit the tcg_gen_insn_start opcode.
*
* @breakpoint_check:
*      When called, the breakpoint has already been checked to match the PC,
*      but the target may decide the breakpoint missed the address
*      (e.g., due to conditions encoded in their flags).  Return true to
*      indicate that the breakpoint did hit, in which case no more breakpoints
*      are checked.  If the breakpoint did hit, emit any code required to
*      signal the exception, and set db-&gt;is_jmp as necessary to terminate
*      the main loop.
*
* @translate_insn:
*      Disassemble one instruction and set db-&gt;pc_next for the start
*      of the following instruction.  Set db-&gt;is_jmp as necessary to
*      terminate the main loop.
*
* @tb_stop:
*      Emit any opcodes required to exit the TB, based on db-&gt;is_jmp.
*
* @disas_log:
*      Print instruction disassembly to log.
*/</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TranslatorOps</span> {</span>
    <span class="hljs-keyword">void</span> (*init_disas_context)(DisasContextBase *db, CPUState *cpu);
    <span class="hljs-keyword">void</span> (*tb_start)(DisasContextBase *db, CPUState *cpu);
    <span class="hljs-keyword">void</span> (*insn_start)(DisasContextBase *db, CPUState *cpu);
    <span class="hljs-keyword">bool</span> (*breakpoint_check)(DisasContextBase *db, CPUState *cpu,
                            <span class="hljs-keyword">const</span> CPUBreakpoint *bp);
    <span class="hljs-keyword">void</span> (*translate_insn)(DisasContextBase *db, CPUState *cpu);
    <span class="hljs-keyword">void</span> (*tb_stop)(DisasContextBase *db, CPUState *cpu);
    <span class="hljs-keyword">void</span> (*disas_log)(<span class="hljs-keyword">const</span> DisasContextBase *db, CPUState *cpu);
} TranslatorOps;

<span class="hljs-comment">/**
* DisasContextBase:
* @tb: Translation block for this disassembly.
* @pc_first: Address of first guest instruction in this TB.
* @pc_next: Address of next guest instruction in this TB (current during
*           disassembly).
* @is_jmp: What instruction to disassemble next.
* @num_insns: Number of translated instructions (including current).
* @max_insns: Maximum number of instructions to be translated in this TB.
* @singlestep_enabled: "Hardware" single stepping enabled.
*
* Architecture-agnostic disassembly context.
*/</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisasContextBase</span> {</span>
    TranslationBlock *tb;
    target_ulong pc_first;
    target_ulong pc_next;
    DisasJumpType is_jmp;
    <span class="hljs-keyword">int</span> num_insns;
    <span class="hljs-keyword">int</span> max_insns;
    <span class="hljs-keyword">bool</span> singlestep_enabled;
} DisasContextBase;
</div></code></pre>
<p>这个结构体中存的都是函数指针，在每个target/translate.c文件中都会对这个结构体进行实例化，结构体中每个成员函数就是对应的功能入口，均在同一个文件中。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TranslatorOps arm_translator_ops = {
    .init_disas_context = arm_tr_init_disas_context,
    .tb_start           = arm_tr_tb_start,
    .insn_start         = arm_tr_insn_start,
    .breakpoint_check   = arm_tr_breakpoint_check,
    .translate_insn     = arm_tr_translate_insn,
    .tb_stop            = arm_tr_tb_stop,
    .disas_log          = arm_tr_disas_log,
};
</div></code></pre>
</li>
<li>
<p>调用translator_loop{accel/tcg/translator.c,accel/tcg/translator.h}函数实现target-&gt;tcg代码的转换。</p>
</li>
</ol>
<h3 id="translatorloop-acceltcgtranslatorcacceltcgtranslatorh">translator_loop {accel/tcg/translator.c,accel/tcg/translator.h}</h3>
<pre><code>``` C
/**
* translator_loop:
* @ops: Target-specific operations.
* @db: Disassembly context.
* @cpu: Target vCPU.
* @tb: Translation block.
*
* Generic translator loop.
*
* Translation will stop in the following cases (in order):
* - When is_jmp set by #TranslatorOps::breakpoint_check.
*   - set to DISAS_TOO_MANY exits after translating one more insn
*   - set to any other value than DISAS_NEXT exits immediately.
* - When is_jmp set by #TranslatorOps::translate_insn.
*   - set to any value other than DISAS_NEXT exits immediately.
* - When the TCG operation buffer is full.
* - When single-stepping is enabled (system-wide or on the current vCPU).
* - When too many instructions have been translated.
*/
void translator_loop(const TranslatorOps *ops, DisasContextBase *db,
                    CPUState *cpu, TranslationBlock *tb);
```
</code></pre>
<p>查看了几个target下的translator_loop函数调用，发现第二个参数db均是在gen_intermediate_code()中定义的一个空结构体。这个变量在translator_loop首先会被初始化，按照函数注释，这个变量中存储的是反汇编内容，应该指的是转换后的tcg码。但是db并没有作为返回值，应该会在函数结束后消亡，应该在translator_loop中子函数中保存了它，还需要进一步观察。</p>
<p>translator_loop函数结构比较简单，流程如下：</p>
<ol>
<li>初始化<code>DisasContext</code></li>
<li><code>Instruction counting</code> 给db-&gt;max_insns变量赋值，这个tb中的将要译码的最大指令数量</li>
<li>ops-&gt;init_disas_context(db, cpu)。 ops成员函数，对每个target会使用对应的函数。Initialize the target-specific portions of DisasContext struct. The generic DisasContextBase has already been initialized. 前面初始化的是DisasContext的公共部分，这里是对每个target调用专有的初始化函数。</li>
<li>tcg_clear_temp_count()。 /* Reset the temp count so that we can identify leaks */</li>
<li>gen_tb_start(db-&gt;tb){/exec/gen-icount.h}。这个文件中有好几个类似函数，文件注释是/* Helpers for instruction counting code generation.  */，应该是在执行过程中的辅助函数，程序计数用？</li>
<li>ops-&gt;tb_start(db, cpu)。ops成员函数，Emit any code required before the start of the main loop，after the generic gen_tb_start().没理解注释含义，待后续查看函数内容再说。</li>
<li>while循环开始，逐条开始译码。
<ol>
<li>程序计数加一，调用ops-&gt;insn_start(db, cpu)</li>
<li>检查调试断点，如果下一条指令是断点，调用ops-&gt;breakpoint_check(db, cpu, bp)，并结束while</li>
<li>调用ops-&gt;translate_insn(db, cpu)进行译码，有一个当前指令书等于最大指令数的特殊判断，不清楚具体作用</li>
<li>结束循环判断。一是db-&gt;is_jmp不是译码下一条指令<code>DISAS_NEXT</code>，二是tcg_op_buf_full() 或者 db-&gt;num_insns &gt;= db-&gt;max_insns，指令数超上限</li>
</ol>
</li>
<li>ops-&gt;tb_stop(db, cpu)。 Emit any opcodes required to exit the TB, based on db-&gt;is_jmp.</li>
<li>gen_tb_end(db-&gt;tb, db-&gt;num_insns);？？</li>
</ol>
<p>下面以openrisc为例逐项解析ops中的各个函数{/target/openrisc/translate.c}
.init_disas_context = openrisc_tr_init_disas_context 新建了一个DisasContext，并对其进行了初始化赋值，不清楚具体每个参数的含义
.tb_start = openrisc_tr_tb_start 设置了寄存器R0，不知为何
.insn_start = openrisc_tr_insn_start 发出tcg_gen_insn_start指令
.breakpoint_check = openrisc_tr_breakpoint_check,设置断点，再下一条指令设置了跳转，并且将跳转类型设置为DISAS_NORETURN，没理解为什么，这样可以再程序停止运行，然后在需要继续的时候由调试器返回？
.translate_insn = openrisc_tr_translate_insn,调用了/scripts/decodetree.py，通过这个脚本生成了一个c文件，decode.inc.c，这文件中包含了译码函数decode，具体指令译码的格式在insns.decode文件中
.tb_stop = openrisc_tr_tb_stop,对于不同类型的跳转进行了分别处理
.disas_log = openrisc_tr_disas_log</p>
<h3 id="tcggencode-tcgtcgc">tcg_gen_code {/tcg/tcg.c}</h3>
<p>tcg_gen_code() {/tcg/tcg.c},将tcg代码转换为host代码，这个函数实现的是前面《TCG-动态翻译》一节描述的过程（这里是tcg-&gt;host的过程，我们要修改的是guest-&gt;tcg的过程，应该不需要更改这里的代码，没有细看）。</p>
<p>（既然qemu已经是c语言写的，那么在qemu编译完成后，在qemu运行过程中动态产生的tcg代码应该就可以直接被host执行了，这里的转换起什么作用？）</p>
<h1 id="tcg%E8%AE%B2%E8%A7%A3">tcg讲解</h1>
<p>https://chemnitzer.linux-tage.de/2012/vortraege/1062
tcg使用方法</p>
<ol>
<li>guest--需要模拟的体系机构，target--运行tcg的体系结构。</li>
<li>直接使用qemu提供的tcg中间函数去构建自己的guest指令，将guest指令转换为tcg执行后再执行</li>
<li>使用tcg_helper来构建复杂guest指令，tcg在运行时会直接调用对应的helper函数，这样，guest指令直接转换为c代码运行</li>
<li>tcg中间代码微指令类型总结https://blog.csdn.net/lulu901130/article/details/45716883</li>
</ol>
<h1 id="%E5%85%B6%E4%BB%96">其他</h1>
<ol>
<li>{/target/xxx/translate.c}: guest ISA speciﬁc code.</li>
<li>{tcg-<em>/</em>/}: host ISA speciﬁc code.</li>
<li>{linux-user/*}: Linux usermode speciﬁc code.</li>
<li>hw/*: Hardware, including video, audio, and boards.</li>
</ol>
<p>https://people.cs.nctu.edu.tw/~chenwj/dokuwiki/doku.php?id=qemu</p>

</body>
</html>
